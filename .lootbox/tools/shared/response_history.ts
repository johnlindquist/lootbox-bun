/**
 * Response History - Save AI agent responses as browsable markdown files
 *
 * Design principles:
 * - Files are the source of truth (no database)
 * - Easily browsable in VS Code/Cursor
 * - YAML frontmatter for metadata
 * - Temporal organization (YYYY/MM/DD)
 * - Simple JSON index regenerated from files
 */

import { existsSync, mkdirSync, readdirSync, statSync } from "node:fs";
import { readFile, writeFile, readdir } from "node:fs/promises";
import { join, basename, dirname } from "node:path";
import { createLogger } from "./index.ts";

const log = createLogger("response_history");

// ============================================================================
// TYPES
// ============================================================================

export interface ResponseMetadata {
  tool: string;
  topic: string;
  query?: string;
  tags?: string[];
  model?: string;
  duration_ms?: number;
  agents?: string[];
  [key: string]: unknown;
}

export interface SavedResponse {
  id: string;
  filepath: string;
  relativePath: string;
}

export interface HistoryEntry {
  id: string;
  filepath: string;
  tool: string;
  topic: string;
  timestamp: string;
  tags: string[];
}

// ============================================================================
// CONFIGURATION
// ============================================================================

/**
 * Get the history directory - uses ~/.lootbox/history for global storage
 * This keeps responses accessible across all projects
 */
export function getHistoryDir(): string {
  const homeDir = process.env.HOME || process.env.USERPROFILE || "~";
  return join(homeDir, ".lootbox", "history");
}

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

/**
 * Save an AI response to the history
 *
 * @param content - The markdown content to save
 * @param metadata - Metadata about the response
 * @returns The saved response info including filepath
 */
export async function saveResponse(
  content: string,
  metadata: ResponseMetadata
): Promise<SavedResponse> {
  const now = new Date();
  const historyDir = getHistoryDir();

  // Build date path: YYYY/MM/DD
  const year = now.getFullYear().toString();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const datePath = join(year, month, day);
  const fullDirPath = join(historyDir, datePath);

  // Ensure directory exists
  if (!existsSync(fullDirPath)) {
    mkdirSync(fullDirPath, { recursive: true });
  }

  // Get next sequence number for today
  const sequence = getNextSequence(fullDirPath);

  // Build filename: HHmm-seq_tool_slug.md
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const timeStr = `${hours}${minutes}`;
  const slug = slugify(metadata.topic);
  const toolName = slugify(metadata.tool);
  const filename = `${timeStr}-${sequence}_${toolName}_${slug}.md`;

  // Build ID
  const id = `${year}-${month}-${day}-${sequence}`;

  // Build full file content with frontmatter
  const fileContent = buildMarkdownFile(id, content, metadata, now);

  // Write file
  const filepath = join(fullDirPath, filename);
  const relativePath = join(datePath, filename);

  await writeFile(filepath, fileContent, "utf-8");

  log.info(`Saved response to ${relativePath}`);

  return { id, filepath, relativePath };
}

/**
 * Build the complete markdown file with YAML frontmatter
 */
function buildMarkdownFile(
  id: string,
  content: string,
  metadata: ResponseMetadata,
  timestamp: Date
): string {
  const frontmatter: Record<string, unknown> = {
    id,
    tool: metadata.tool,
    topic: metadata.topic,
    timestamp: timestamp.toISOString(),
  };

  // Add optional fields if present
  if (metadata.query) frontmatter.query = metadata.query;
  if (metadata.tags?.length) frontmatter.tags = metadata.tags;
  if (metadata.model) frontmatter.model = metadata.model;
  if (metadata.duration_ms) frontmatter.duration_ms = metadata.duration_ms;
  if (metadata.agents?.length) frontmatter.agents = metadata.agents;

  // Add any extra metadata fields
  for (const [key, value] of Object.entries(metadata)) {
    if (!frontmatter[key] && value !== undefined) {
      frontmatter[key] = value;
    }
  }

  const yaml = serializeYaml(frontmatter);
  const dateStr = timestamp.toISOString().split("T")[0];
  const timeStr = timestamp.toISOString().split("T")[1].split(".")[0];

  return `---
${yaml}
---

# ${metadata.topic}

${metadata.query ? `## Query\n\n> ${metadata.query}\n\n` : ""}## Response

${content}

---
*Generated by ${metadata.tool} on ${dateStr} at ${timeStr} UTC*
`;
}

/**
 * Simple YAML serializer (avoids external dependency)
 */
function serializeYaml(obj: Record<string, unknown>, indent = 0): string {
  const spaces = "  ".repeat(indent);
  const lines: string[] = [];

  for (const [key, value] of Object.entries(obj)) {
    if (value === undefined || value === null) continue;

    if (Array.isArray(value)) {
      if (value.length === 0) continue;
      lines.push(`${spaces}${key}:`);
      for (const item of value) {
        if (typeof item === "object") {
          lines.push(`${spaces}  -`);
          lines.push(serializeYaml(item as Record<string, unknown>, indent + 2));
        } else {
          lines.push(`${spaces}  - ${JSON.stringify(item)}`);
        }
      }
    } else if (typeof value === "object") {
      lines.push(`${spaces}${key}:`);
      lines.push(serializeYaml(value as Record<string, unknown>, indent + 1));
    } else if (typeof value === "string" && (value.includes("\n") || value.includes(":"))) {
      lines.push(`${spaces}${key}: ${JSON.stringify(value)}`);
    } else {
      lines.push(`${spaces}${key}: ${JSON.stringify(value)}`);
    }
  }

  return lines.join("\n");
}

/**
 * Get the next sequence number for the current day directory
 */
function getNextSequence(dirPath: string): string {
  if (!existsSync(dirPath)) return "001";

  const files = readdirSync(dirPath).filter((f) => f.endsWith(".md"));
  let maxSeq = 0;

  for (const file of files) {
    // Parse sequence from filename like "1430-001_tool_slug.md"
    const match = file.match(/^\d{4}-(\d{3})_/);
    if (match) {
      const seq = parseInt(match[1], 10);
      if (seq > maxSeq) maxSeq = seq;
    }
  }

  return String(maxSeq + 1).padStart(3, "0");
}

/**
 * Create a URL-safe slug from text
 */
function slugify(text: string): string {
  if (!text) return "untitled";
  return text
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)+/g, "")
    .slice(0, 50);
}

// ============================================================================
// SEARCH & BROWSE FUNCTIONS
// ============================================================================

/**
 * List recent responses
 */
export async function listRecent(limit = 20): Promise<HistoryEntry[]> {
  const historyDir = getHistoryDir();
  if (!existsSync(historyDir)) return [];

  const entries: HistoryEntry[] = [];

  // Walk through year/month/day directories in reverse order
  const years = getSortedDirs(historyDir).reverse();

  outer: for (const year of years) {
    const months = getSortedDirs(join(historyDir, year)).reverse();
    for (const month of months) {
      const days = getSortedDirs(join(historyDir, year, month)).reverse();
      for (const day of days) {
        const dayDir = join(historyDir, year, month, day);
        const files = readdirSync(dayDir)
          .filter((f) => f.endsWith(".md"))
          .sort()
          .reverse();

        for (const file of files) {
          const filepath = join(dayDir, file);
          const entry = await parseFileMetadata(filepath);
          if (entry) {
            entries.push(entry);
            if (entries.length >= limit) break outer;
          }
        }
      }
    }
  }

  return entries;
}

/**
 * Search responses by tool, tags, or text
 */
export async function searchResponses(opts: {
  tool?: string;
  tags?: string[];
  query?: string;
  limit?: number;
}): Promise<HistoryEntry[]> {
  const all = await listRecent(1000); // Get last 1000 entries
  let results = all;

  if (opts.tool) {
    results = results.filter((e) => e.tool === opts.tool);
  }

  if (opts.tags?.length) {
    results = results.filter((e) =>
      opts.tags!.some((tag) => e.tags.includes(tag))
    );
  }

  if (opts.query) {
    const q = opts.query.toLowerCase();
    results = results.filter(
      (e) =>
        e.topic.toLowerCase().includes(q) ||
        e.tags.some((t) => t.toLowerCase().includes(q))
    );
  }

  return results.slice(0, opts.limit || 20);
}

/**
 * Get sorted subdirectories
 */
function getSortedDirs(dirPath: string): string[] {
  if (!existsSync(dirPath)) return [];
  return readdirSync(dirPath)
    .filter((f) => {
      const fullPath = join(dirPath, f);
      return existsSync(fullPath) && statSync(fullPath).isDirectory();
    })
    .sort();
}

/**
 * Parse metadata from a saved response file
 */
async function parseFileMetadata(filepath: string): Promise<HistoryEntry | null> {
  try {
    const content = await readFile(filepath, "utf-8");
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) return null;

    const yaml = frontmatterMatch[1];

    // Simple YAML parsing (just key: value)
    const meta: Record<string, unknown> = {};
    let currentKey = "";
    let inArray = false;
    const arrayValues: string[] = [];

    for (const line of yaml.split("\n")) {
      if (line.startsWith("  - ") && inArray) {
        // Array item
        const value = line.replace("  - ", "").trim();
        arrayValues.push(value.replace(/^"|"$/g, ""));
      } else if (line.match(/^[a-z_]+:/)) {
        // New key
        if (inArray && currentKey) {
          meta[currentKey] = [...arrayValues];
          arrayValues.length = 0;
        }
        inArray = false;

        const colonIdx = line.indexOf(":");
        currentKey = line.slice(0, colonIdx);
        const value = line.slice(colonIdx + 1).trim();

        if (value === "") {
          inArray = true;
        } else {
          meta[currentKey] = value.replace(/^"|"$/g, "");
        }
      }
    }

    if (inArray && currentKey) {
      meta[currentKey] = [...arrayValues];
    }

    return {
      id: String(meta.id || ""),
      filepath,
      tool: String(meta.tool || "unknown"),
      topic: String(meta.topic || "Untitled"),
      timestamp: String(meta.timestamp || ""),
      tags: Array.isArray(meta.tags) ? meta.tags.map(String) : [],
    };
  } catch {
    return null;
  }
}

// ============================================================================
// INDEX MANAGEMENT (Optional - regenerate from files)
// ============================================================================

/**
 * Rebuild the index.json from all files
 * This is optional - can be run periodically or on demand
 */
export async function rebuildIndex(): Promise<{ entries: number; file: string }> {
  const historyDir = getHistoryDir();
  const entries = await listRecent(10000);

  const index = {
    version: 1,
    generated: new Date().toISOString(),
    total_count: entries.length,
    entries: entries.map((e) => ({
      id: e.id,
      filepath: e.filepath.replace(historyDir + "/", ""),
      tool: e.tool,
      topic: e.topic,
      timestamp: e.timestamp,
      tags: e.tags,
    })),
    by_tool: {} as Record<string, number>,
  };

  // Count by tool
  for (const entry of entries) {
    index.by_tool[entry.tool] = (index.by_tool[entry.tool] || 0) + 1;
  }

  const indexPath = join(historyDir, "index.json");
  await writeFile(indexPath, JSON.stringify(index, null, 2), "utf-8");

  return { entries: entries.length, file: indexPath };
}

// ============================================================================
// HELPER FOR TOOLS
// ============================================================================

/**
 * Helper to save a tool response with common patterns
 * Use this in your tools for consistent saving
 */
export async function saveToolResponse(opts: {
  tool: string;
  topic: string;
  content: string;
  query?: string;
  tags?: string[];
  model?: string;
  duration_ms?: number;
  agents?: string[];
  extras?: Record<string, unknown>;
}): Promise<SavedResponse> {
  return saveResponse(opts.content, {
    tool: opts.tool,
    topic: opts.topic,
    query: opts.query,
    tags: opts.tags,
    model: opts.model,
    duration_ms: opts.duration_ms,
    agents: opts.agents,
    ...opts.extras,
  });
}
